---
title: 对象的私有、静态（类）、自有（实例）、原型属性与方法
updated: 2018-01-03 16:17:53
date: 2018-01-02    15:14:56
tags: [总结]
categories: [JavaScript]
---
#### es5代码

```js
//对象构造函数
function Baby(name) {
    var className = "Baby";
    //私有属性，只能在对象构造函数内部使用

    this.name = name;
    this.weight = '3kg';
    //自有属性，每个实例私有，在对象实例化后调用，实例属性在对象实力化后创建
    
    this.hello = function() {
        console.log(this.name);
        console.log(this.msg()); //使用原型方法扩充的方法可以在类内部使用
        console.log(this.sex); //使用原型方法扩充的属性可以在类内部使用
        console.log(Baby.age, this.age); //静态属性调用时格式为[对象.静态属性]
    }//对象方法
}

Baby.Run = function() {
    console.log("跑起来！！！");
}
//类方法 (实际是静态方法直接调用)，只有类才能访问类方法，实例不能访问 ，在类方法中通过this只能访问类属性不能访问其他属性，即在本例中，Run方法只能访问到this.age

Baby.prototype.msg = function() {
    console.log("我叫：" + this.name); 
}
//原型方法，如果原型方法当作静态方法直接调用时，this.name无法被调用

Baby.age = 20; 
//类属性 在类的外部。公有静态属性不能使用 【this.属性】，只能使用 【对象.属性】 调用，只有类才能访问类属性，实例不能访问  

Baby.prototype.sex = "男娃娃"
//原型属性，所有实例共有，【this.属性】这种写法访问时，先会访问实例对象属性，没有实例对象属性就会访问原型属性 ，也可以当成公有静态属性使用【对象.prototype.原型属性。 

var bob = new Baby("bob"); 
//自有方法和原型方法需要实例化对象后才可以使

Baby.name
//"Baby" :每一个类都有一个基本的name属性

bob.name
//"bob"

Baby.weight
//undefined

bob.weight
//"3kg"

Baby.hello()
//Uncaught TypeError: Baby.hello is not a function

bob.hello()
// bob
// 我叫：bob
// undefined :this.msg没有返回所以undefined
// 男娃娃
// 20 undefined

Baby.Run(); //跑起来！！！
//类方法也是静态方法，可以直接使用 【对象.静态方法()】

bob.run()// TypeError: bob.run is not a function

Baby.msg()
// Uncaught TypeError: Baby.msg is not a function

Baby.prototype.msg()
// 我叫：undefined
//原型方法当成静态方法使用时【对象.prototype.方法()】 

bob.msg();
// 我叫：bob
//原型方法必须实例化对象

bob.age;
// undefined 
//错误，公有静态属性只能使用 【对象.属性】调用

Baby.age
// 20

Baby.prototype.sex
// 男娃娃
//原型属性当作静态属性使用时【对象.prototype.方法()】

Baby.sex
// undefined

bob.sex
// 男娃娃
```

*****
#### es6代码

```js
class Point {
  constructor(x, y) {
    //对象属性、方法
    this.x = x;
    this.y = y;
    this.fn = function() {
        return 'skyline'
    };
  }
  
  //自有属性，使用存取器
  get prop() {
    return 'skyline getter';
  }
  set prop(value) {
    console.log('skyline setter: '+value);
  }

  //原型方法
  //Point.prototype.toString = function () {
  //  return '(' + this.x + ', ' + this.y + ')';
  //};
  //的语法糖
  toString() {
    return '(' + this.x + ', ' + this.y + ')';
  }
  
  //类方法
  static classMethod() {
    return 'hello skyline';
  }
}

//类属性，ES6 明确规定，Class 内部只有静态方法，没有静态属性，不过有其他提案，不拓展
Point.prop = 1;
```

*****
#### 总结
* 静态属性方法，可以直接通过类进行访问的
* 实例属性方法是需要创建实例对象进行访问的
* 相互之间不能串访


> 本文作者： Skyline(lty)
本文链接： [http://www.skyline.show/对象的私有、静态（类）、自有（实例）、原型属性与方法.html](http://www.skyline.show/对象的私有、静态（类）、自有（实例）、原型属性与方法.html)
版权声明： 本博客所有文章除特别声明外，均采用 [CC BY-NC-SA 3.0 许可协议](https://creativecommons.org/licenses/by-nc-sa/3.0/)。转载请注明出处！
