            ---
            title: HTTPS加密方式
            updated: 2022-02-03	14:21:52
            
            
            
            ---
            >作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激
            
            
### HTTPS概述
#### 加密缘由
明文传输的数据在经过wifi热点、路由、通信服务运营商等物理节点时信息容易被劫持暴露而不被发觉
容易被中间人攻击，存在以下风险
* 窃听
* 篡改
* 冒充

#### HTTPS
超文本传输安全协议（（HyperText Transfer Protocol Secure）也被称为HTTP over TLS，HTTP over SSL）
HTTPS开发是为了解决上述风险，提供对网络服务器的认证，保证交换信息的机密性和完整性，在HTTP的基础上，我们需要进一步做信息传输加密，数据完整校验，身份认证等工作。
#### 与HTTP对比
<!--more-->
* 端口：HTTPS 443，HTTP 80
* 传输： HTTPS密文， HTTP 明文
* 证书：HTTPS需要，HTTP 不需要

![](https://cdn.jsdelivr.net/gh/skylinety/blog-pics/HTTPS加密方式/resources/206E0D3B34F008B147F154636E11CDD7.jpg)

（图源：<https://juejin.im/post/6844903604868874247>）

*****
### 加密方式
常见的加密方式中，是选择对称加密，非对称加密还是算不上加密的摘要算法？
以下进行加密方式选择的讨论
#### 摘要算法
摘要算法无法逆向获取原文内容，没有可行性。
#### 对称加密（共享密钥加密算法）
对称加密算法 中，使用的密钥只有一个，发送 和 接收 双方都使用这个密钥对数据进行 加密 和 解密
##### 可行性
###### 存在密钥传输问题
如何保证密钥传输给众多客户端过程中不被泄露？
网络存在通信实体庞大，不是单单的一对一的问题，往往一台服务器对应众多的访问客户，如何把密钥传递给庞大的客户群并在传输过程不被泄露，是关键问题。
#### 非对称加密
公钥加密，私钥解密
##### 可行性
###### 单组非对称加密密钥
只能保证单边通信可靠性
使用一组非对称加密密钥，存在如下问题。客户端公钥加密，服务器私钥解密，客户端到服务器的通信是可靠的，但是反之，服务器向客户端传递信息，如果用私钥加密，则公开的公钥都能解密
###### 两组公钥私钥
客户端服务器分别保留一把公钥，一把私钥，公钥加密，私钥解密
**可行性差的主要原因是非对称加密非常耗时**
#### 对称 + 非对称
##### 本质
**采用用非对称算法传递对称密钥，采用对称加密算法加密传输数据**
##### 过程
* 客户端发起请求
* 服务器明文发送公钥A，客户端获取公钥A
* 客户端生成密钥X，用公钥A加密密钥X得到密文XXXA后传给服务器
* 服务器私钥A'解密密文XXXA获取密钥X
* 双方用密钥X对称加解密进行通信

##### 过程图示

![anigif.gif](https://cdn.jsdelivr.net/gh/skylinety/blog-pics/HTTPS加密方式/resources/5B02C61921A0B6F1A5678D0F74D4F022.gif)

*****
### 中间人攻击
#### 概述
非对称加密算法在传递公钥过程中存在公钥被中间人截取篡改的风险。
只要是采用了非对称加密算法，都会存在中间人攻击的风险。
##### 非对称加密中间人攻击

![](https://cdn.jsdelivr.net/gh/skylinety/blog-pics/HTTPS加密方式/resources/50E14FEDDD279C38F6E0F02E7589BDEC.jpg)

* 中间人获取服务器的公钥A拦截
* 中间人把自己生产的公钥B返给客户端
* 客户端用公钥B加密明文"QQ:123 密码：123"成密文XXXB
* 中间人用私钥B'解密获取明文
* 中间人用公钥A加密明文为XXXA并传给服务器

上述过程中，客户端与服务器正常通信，难以发觉信息已经被泄露。

##### 信息抵赖
由于存在中间人的已知风险，如果不解决非对称中的这个漏洞，即便不存在中间人攻击，对于错误的消息，服务器可以不承认。
（中间过程传递的是密文，为了便于理解直接明文展示）

![](https://cdn.jsdelivr.net/gh/skylinety/blog-pics/HTTPS加密方式/resources/C6CE0D53E606C13393E7CBA6E76AACC4.jpg)

##### 非对称与对称方案中的中间人攻击
上述非对称与对称方案并没有解决针对非对称加密算法的此项漏洞，中间人可以在上述非对称与对称方案中进行攻击。具体过程如下
* 客户端发起请求
* 服务器发送公钥A，被拦截，中间人获取公钥A
* 中间人生成公钥B，私钥B'
* 中间人发送公钥B，客户端获取公钥B
* 客户端生成密钥X，用公钥B加密密钥X得到密文XXXB
* 客户端发送密文XXXB，中间人截取密文
* 中间人用私钥B'解密获取密钥X
* 中间人用公钥A加密密钥X得到XXXA，并发送给服务器
* 服务器私钥A'解密XXXA获取密钥X
* 双方用密钥X对称加解密进行通信

###### 过程图示

![anigif.gif](https://cdn.jsdelivr.net/gh/skylinety/blog-pics/HTTPS加密方式/resources/1ADC3A5F4D04361EF2FF96840720329D.gif)

最终中间人成功的获取了客户端与服务器此次通信的密钥X，此次通行中所用信息都可被中间人解密获取
#### 根本原因
**中间人成功攻击的根本原因是浏览器无法确认获取的公钥真实性**
*****
### 数字证书与签名
#### 数字证书
为了保证公钥的正确真实性，需要权威CA机构(证书授权中心/Certificate Authority )来颁发数字证书，数字证书里有证书持有者（持有网站）、持有者公钥等信息。
在传输过程中，服务器传输公钥A改为传输数字证书，客户端从证书里获取取公钥A
#### 数字签名
如何保证数字证书文件的真实性？
数字证书既然通过网络传输，那么中间人也可以直接拦截后篡改内容之后再返回。同样，中间人也可以向同一家机构申请证书然后换成自己的证书。
如何避免这些问题？
世界没有完全相同的一片叶子，也没有完全相同的一个人。
人有指纹，有虹膜，还可以用签名来标识身份信息，在这个场景中，有没有可以借鉴的地方？
通过数字签名
##### 签发证书
CA机构用非对称加密算法拥有一对公私钥，用摘要算法对证书明文信息获取摘要，然后用私钥对摘要进行加密形成签名，最后将签名与使用的摘要算法置入证书当中。这里，不直接用私钥加密明文主要是因为非对称加密算法存在性能问题，加密内容不宜过长，加密摘要显然优于加密明文。

![](https://cdn.jsdelivr.net/gh/skylinety/blog-pics/HTTPS加密方式/resources/5DC872B3801F62A3077D9D473631545A.jpg)

##### 验证签名
1. 客户端用CA机构公钥解密数字签名得到摘要A（**由于是客户端（浏览器等）信任的机构，所以其保有对应证书签发机构的公钥**）
2. 客户端用证书中的摘要算法对明文进行摘要得到摘要B
3. 对比摘要A与摘要B是否一致

![](https://cdn.jsdelivr.net/gh/skylinety/blog-pics/HTTPS加密方式/resources/13397A6392668084153F342B1A3C8DC3.jpg)

如果摘要对比一致，则验证成功。

##### 不可篡改
为什么数字签名可以保证证书不被篡改？
中间人即便篡改明文信息并按照摘要算法重新生成摘要，但是由于没有CA机构的私钥，无法对摘要加密形成有效签名。
在客户端验证签名过程中（上节步骤1中），无法正确获取摘要A，验证失败！
##### 证书掉包
既然签名不可伪造，证书内容不可篡改，那么，是否可以将证书整体掉包？
证书是可以被掉包的，但是由于证书里包含了申请者的信息比如域名，浏览器等客户端会把证书里的域名与请求时的域名进行比对，掉包随即就被发现。
证书被掉包时，浏览器会有如下警告

![](https://cdn.jsdelivr.net/gh/skylinety/blog-pics/HTTPS加密方式/resources/5BB52CC17D71512B6205349B19751BD1.png)![](https://cdn.jsdelivr.net/gh/skylinety/blog-pics/HTTPS加密方式/resources/88AE731196443B8898EAA56C0EACB2D0.jpg)

##### 签名本质
**采用摘要算法获取明文摘要，采用非对称加密算法私钥加密摘要**
##### 证书实例
证书通常包含以下信息：
* 申请者公钥
* 申请者的组织信息和个人信息
* 签发机构CA的信息
* 有效时间、证书序列号等信息明文
* 签名与签名算法

![](https://cdn.jsdelivr.net/gh/skylinety/blog-pics/HTTPS加密方式/resources/E66B1F91FA33704AA7642ECC6EDA6DBD.jpg)

##### 证书申请

![](https://cdn.jsdelivr.net/gh/skylinety/blog-pics/HTTPS加密方式/resources/7585846312F7C656F13A459AADC43B50.png)

（出自：<http://yunlaiwu.github.io/>）

##### 本地CA机构公钥
加入数字证书是为了让客户端准确获取服务器的公钥。但是要想解开证书中的签名，必须有签发机构的公钥，这些公钥从何而来？
事实上，操作系统、浏览器等会在安装时附带其认为安全的 CA机构的根证书列表。
例如，在HTTPS通信中使用的服务端证书是CA机构W签发的，如果在浏览器中存在W的根证书，那么就可以直接拿到其公钥。
在实际过程中根证书往往不直接颁发服务端证书，而是授权给中间证书。
##### 证书链
完整的证书链一般有三级
* 服务端证书（end-user certificates）
* 中间证书（intermediates Certificates）
* 根证书（root Certificates）

点击chrome上这个锁图标，可以看一个https网站经过了几级证书认证，并可以查看每一级证书详细信息

![](https://cdn.jsdelivr.net/gh/skylinety/blog-pics/HTTPS加密方式/resources/D0DC36E595FCD4FC1F563AE67917853E.jpg)

**不管存在多少级证书，其最终的目的都是为了验证服务端证书未篡改。**
中间证书可以存在多级，中间证书不会影响验证结果，证书的签发与验证原理不变，最终只要通过证书链最终被CA根证书验证通过即可
中间证书的优势：
* 分级管理，减少根证书管理量，高效签发与管理证书
* 根证书内置与客户端中，一旦根证书对应的私钥泄露，吊销根证书非常困难，而中间证书私钥泄露，可先在线吊销

常见证书链如下所示

![](https://cdn.jsdelivr.net/gh/skylinety/blog-pics/HTTPS加密方式/resources/95585823EED7AA6BF3D447928A82BBD2.jpg)

##### 不被信任证书
当证书不是由受信任的机构颁发的，浏览器也会警告，用户可以根据网站提示安装证书或进行其他进一步操作。

![](https://cdn.jsdelivr.net/gh/skylinety/blog-pics/HTTPS加密方式/resources/52D49F4E0B961719AF0FD35F97F2AFC6.jpg)

##### 服务端如何找到正确的密钥X？
一台服务器一般情况是与多个客户端保持连接的，每一个连接都有自己的密钥，如何对对应的客户端用正确的密钥X呢？
真正的数据传输前，需要进行SSL/TSL握手，密钥X的传递包含其中。当连接建立后，服务器会为每个客户端维护一个session ID，客户端的每一个请求都会携带该sessionID，而服务器正是通过sessionID找到正确的密钥来解密内容



****
### HTTPS请求流程图解
HTTPS请求的大致流程如下所示

![](https://cdn.jsdelivr.net/gh/skylinety/blog-pics/HTTPS加密方式/resources/1706630D2F6DDCBF7002BAFFAEE2D75E.jpg)

### 拓展
#### SSH
常用的SSH协议中(Secure Shell安全外壳协议，简称SSH)，采用的就是非对称加密。
SSH不像https协议，SSH协议的公钥是没有证书中心（CA）公证，都是自己签发的，那么远程登录使用SSH时是如何防止中间人攻击的？
SSH登录有两种方式：
* 口令登录
* 公钥登录

##### 口令登录
第一次登录时服务器会返回公钥并会给出公钥指纹（摘要算法获取公钥的摘要），用户可以拿到指纹与服务器提供商提供的指纹做对比，验证是否一致
```
　　$ ssh user@host

　　The authenticity of host 'host (12.18.429.21)' can't be established.

　　RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.

　　Are you sure you want to continue connecting (yes/no)?
　　
```
如果一致，用户确认之后，公钥将会加密用户输入的密码给服务器，让后建立连接
##### 公钥登录
使用口令登录，每次都要输入用户名密码，非常繁琐。
在公钥登录方式中，用户自己生成一堆非对称密钥。私钥存于本地，公钥拷贝到服务器，建立连接即可。
### 参考资料
> [彻底搞懂HTTPS的加密机制](https://juejin.im/post/6844903670044164109)
[HTTPS安全性原理以及其对前端的影响](http://yunlaiwu.github.io/blog/2016/12/18/HTTPS%E5%AE%89%E5%85%A8%E6%80%A7%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E5%85%B6%E5%AF%B9%E5%89%8D%E7%AB%AF%E7%9A%84%E5%BD%B1%E5%93%8D/)